#!/usr/bin/env node

/**
 * Translation Type Generator
 *
 * This script generates TypeScript type definitions from the English (en.json) translation file.
 * It ensures type safety when accessing translations throughout the application.
 *
 * Usage: node scripts/generate-translation-types.js
 */

const fs = require('fs');
const path = require('path');

const MESSAGES_DIR = path.join(__dirname, '../messages');
const SOURCE_FILE = path.join(MESSAGES_DIR, 'en.json');
const OUTPUT_FILE = path.join(__dirname, '../src/types/translations.generated.ts');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  cyan: '\x1b[36m',
  yellow: '\x1b[33m',
};

const log = (color, ...args) => {
  console.log(color, ...args, colors.reset);
};

/**
 * Generate TypeScript interface for a nested object
 */
const generateInterface = (obj, indentLevel = 1) => {
  const indent = '  '.repeat(indentLevel);
  const lines = [];

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      lines.push(`${indent}${key}: {`);
      lines.push(generateInterface(value, indentLevel + 1));
      lines.push(`${indent}};`);
    } else {
      lines.push(`${indent}${key}: string;`);
    }
  }

  return lines.join('\n');
};

/**
 * Get all namespace keys from the translation object
 */
const getNamespaces = obj => {
  return Object.keys(obj).filter(key => typeof obj[key] === 'object' && obj[key] !== null);
};

/**
 * Generate union type for all possible translation keys in a namespace
 */
const generateKeyUnion = (obj, prefix = '') => {
  const keys = [];

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      keys.push(...generateKeyUnion(value, fullKey));
    } else {
      keys.push(fullKey);
    }
  }

  return keys;
};

/**
 * Main function to generate types
 */
const generateTypes = () => {
  log(colors.cyan, '\nüî® Generating translation types...\n');

  // Read source file
  if (!fs.existsSync(SOURCE_FILE)) {
    console.error(`‚ùå Source file not found: ${SOURCE_FILE}`);
    process.exit(1);
  }

  const sourceContent = JSON.parse(fs.readFileSync(SOURCE_FILE, 'utf8'));
  const namespaces = getNamespaces(sourceContent);

  log(colors.yellow, `üìã Found ${namespaces.length} namespaces`);

  // Generate TypeScript file content
  const typeDefinitions = [
    '/**',
    ' * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY',
    ' * ',
    ' * This file is automatically generated from messages/en.json',
    ' * Run `npm run generate:types` to regenerate',
    ' */',
    '',
    '// Full translation structure',
    'export interface TranslationMessages {',
    generateInterface(sourceContent, 1),
    '}',
    '',
    '// Namespace union type',
    `export type TranslationNamespace = ${namespaces.map(ns => `'${ns}'`).join(' | ')};`,
    '',
  ];

  // Generate key types for each namespace
  typeDefinitions.push('// Keys for each namespace');
  for (const namespace of namespaces) {
    const keys = generateKeyUnion(sourceContent[namespace]);
    const unionType = keys.map(k => `'${k}'`).join(' | ');
    typeDefinitions.push(`export type ${namespace.charAt(0).toUpperCase() + namespace.slice(1)}Keys = ${unionType};`);
  }

  typeDefinitions.push('');

  // Generate NestedKeyOf utility type
  typeDefinitions.push('// Utility type for nested keys');
  typeDefinitions.push('export type NestedKeyOf<T> = T extends object');
  typeDefinitions.push('  ? {');
  typeDefinitions.push('      [K in keyof T]: K extends string');
  typeDefinitions.push('        ? T[K] extends object');
  typeDefinitions.push('          ? `${K}.${NestedKeyOf<T[K]> & string}` | K');
  typeDefinitions.push('          : K');
  typeDefinitions.push('        : never;');
  typeDefinitions.push('    }[keyof T]');
  typeDefinitions.push('  : never;');
  typeDefinitions.push('');

  // Type for all translation keys
  typeDefinitions.push('// All possible translation keys');
  typeDefinitions.push('export type TranslationKey<NS extends TranslationNamespace> = ');
  typeDefinitions.push('  NestedKeyOf<TranslationMessages[NS]>;');
  typeDefinitions.push('');

  // Write to file
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, typeDefinitions.join('\n'), 'utf8');

  log(colors.green, `‚úÖ Type definitions generated successfully!`);
  log(colors.green, `üìÑ Output: ${OUTPUT_FILE}\n`);
};

// Run the generator
try {
  generateTypes();
} catch (error) {
  console.error('\n‚ùå Error generating types:');
  console.error(error);
  process.exit(1);
}


